Starting With 0 @ 0
ip=0 [0, 0, 0, 0, 0, 0] addi 2 16 2 [0, 0, 16, 0, 0, 0]
ip=17 [0, 0, 17, 0, 0, 0] addi 3 2 3 [0, 0, 17, 2, 0, 0]
ip=18 [0, 0, 18, 2, 0, 0] mulr 3 3 3 [0, 0, 18, 4, 0, 0]
ip=19 [0, 0, 19, 4, 0, 0] mulr 2 3 3 [0, 0, 19, 76, 0, 0]
ip=20 [0, 0, 20, 76, 0, 0] muli 3 11 3 [0, 0, 20, 836, 0, 0]
ip=21 [0, 0, 21, 836, 0, 0] addi 5 2 5 [0, 0, 21, 836, 0, 2]
ip=22 [0, 0, 22, 836, 0, 2] mulr 5 2 5 [0, 0, 22, 836, 0, 44]
ip=23 [0, 0, 23, 836, 0, 44] addi 5 8 5 [0, 0, 23, 836, 0, 52]
ip=24 [0, 0, 24, 836, 0, 52] addr 3 5 3 [0, 0, 24, 888, 0, 52]
ip=25 [0, 0, 25, 888, 0, 52] addr 2 0 2 [0, 0, 25, 888, 0, 52]
===> This built up to 888, and then stops as IR->26 after this, not 27..
ip=26 [0, 0, 26, 888, 0, 52] seti 0 4 2 [0, 0, 0, 888, 0, 52]
===> Jumps to 1 AFTER this,
     888 is the counter, so it will do some set of instructions 888 times..
     [3] IS COUNTER LIMIT
ip=1 [0, 0, 1, 888, 0, 52] seti 1 2 4 [0, 0, 1, 888, 1, 52]
ip=2 [0, 0, 2, 888, 1, 52] seti 1 8 1 [0, 1, 2, 888, 1, 52]
===> 1&2 just put 1s in reg 4 and 1

===> Repetition of 3->11 happens from here
ip=3 [0, 1, 3, 888, 1, 52] mulr 4 1 5 [0, 1, 3, 888, 1, 1]
  [4]*[1] => [5]
ip=4 [0, 1, 4, 888, 1, 1] eqrr 5 3 5 [0, 1, 4, 888, 1, 0]
  [5]==[3] => [5]
ip=5 [0, 1, 5, 888, 1, 0] addr 5 2 2 [0, 1, 5, 888, 1, 0]
ip=6 [0, 1, 6, 888, 1, 0] addi 2 1 2 [0, 1, 7, 888, 1, 0]
ip=8 [0, 1, 8, 888, 1, 0] addi 1 1 1 [0, 2, 8, 888, 1, 0]
ip=9 [0, 2, 9, 888, 1, 0] gtrr 1 3 5 [0, 2, 9, 888, 1, 0]
====> Each set adds 1 to ACC in [1]
===> This is checking if ACC in [1] > LIM [3] => [5] 
ip=10 [0, 2, 10, 888, 1, 0] addr 2 5 2 [0, 2, 10, 888, 1, 0]
===> This sets IPTR to IPTR + [5] (no change) whilst< LIMIT
ip=11 [0, 2, 11, 888, 1, 0] seti 2 6 2 [0, 2, 2, 888, 1, 0]
=> JUMP to @1 AGAIN

When Limit reached => 12...

@ 12 => [_, LIMIT + 1, 11, LIMIT, 1, 1]

it does 12->15 which adds 1 to the [4] and loops to 2, whih starts loop again
  which is another LIMIT times

                                                    [1..2..3..4....]
ip=3 [0, 1, 3, 888, 1, 52] mulr 4 1 5 [0, 1, 3, 888, 1, 1]
  [4]*[1] => [5]
ip=4 [0, 1, 4, 888, 1, 1] eqrr 5 3 5 [0, 1, 4, 888, 1, 0]
  [5]==[3] => [5]


SO:
ip=3 [1, n, 3, 10551288, m, 0]
4 => TRUE?   n x m = 10551288
  m = 2, n = 5_275_644


ip=3 [1, 5275644, 3, 10551288, 2, 1] mulr 4 1 5 [1, 5275644, 3, 10551288, 2, 10551288]
ip=4 [1, 5275644, 4, 10551288, 2, 10551288] eqrr 5 3 5 [1, 5275644, 4, 10551288, 2, 1]
ip=5 [1, 5275644, 5, 10551288, 2, 1] addr 5 2 2 [1, 5275644, 6, 10551288, 2, 1]

=> SEVEN works if n x m == LIMIT
ip=7 [1, 5275644, 7, 10551288, 2, 1] addr 4 0 0 [3, 5275644, 7, 10551288, 2, 1]
=> adds DIVISOR (m) -> [0]

ip=8 [3, 5275644, 8, 10551288, 2, 1] addi 1 1 1 [3, 5275645, 8, 10551288, 2, 1]
ip=9 [3, 5275645, 9, 10551288, 2, 1] gtrr 1 3 5 [3, 5275645, 9, 10551288, 2, 0]
ip=10 [3, 5275645, 10, 10551288, 2, 0] addr 2 5 2 [3, 5275645, 10, 10551288, 2, 0]
ip=11 [3, 5275645, 11, 10551288, 2, 0] seti 2 6 2 [3, 5275645, 2, 10551288, 2, 0]



@ 14 for LIMIT-TH time
     => [_, LIMIT + 1, 13, LIMIT, LIMIT +1, 1]

ip=3 [0, 2, 3, 888, 1, 0] mulr 4 1 5 [0, 2, 3, 888, 1, 2]
ip=4 [0, 2, 4, 888, 1, 2] eqrr 5 3 5 [0, 2, 4, 888, 1, 0]
ip=5 [0, 2, 5, 888, 1, 0] addr 5 2 2 [0, 2, 5, 888, 1, 0]
ip=6 [0, 2, 6, 888, 1, 0] addi 2 1 2 [0, 2, 7, 888, 1, 0]
ip=8 [0, 2, 8, 888, 1, 0] addi 1 1 1 [0, 3, 8, 888, 1, 0]
ip=9 [0, 3, 9, 888, 1, 0] gtrr 1 3 5 [0, 3, 9, 888, 1, 0]
ip=10 [0, 3, 10, 888, 1, 0] addr 2 5 2 [0, 3, 10, 888, 1, 0]
ip=11 [0, 3, 11, 888, 1, 0] seti 2 6 2 [0, 3, 2, 888, 1, 0]
ip=3 [0, 3, 3, 888, 1, 0] mulr 4 1 5 [0, 3, 3, 888, 1, 3]




Starting With 0 @ 1
ip=0 [1, 0, 0, 0, 0, 0] addi 2 16 2 [1, 0, 16, 0, 0, 0]
ip=17 [1, 0, 17, 0, 0, 0] addi 3 2 3 [1, 0, 17, 2, 0, 0]
ip=18 [1, 0, 18, 2, 0, 0] mulr 3 3 3 [1, 0, 18, 4, 0, 0]
ip=19 [1, 0, 19, 4, 0, 0] mulr 2 3 3 [1, 0, 19, 76, 0, 0]
ip=20 [1, 0, 20, 76, 0, 0] muli 3 11 3 [1, 0, 20, 836, 0, 0]
ip=21 [1, 0, 21, 836, 0, 0] addi 5 2 5 [1, 0, 21, 836, 0, 2]
ip=22 [1, 0, 22, 836, 0, 2] mulr 5 2 5 [1, 0, 22, 836, 0, 44]
ip=23 [1, 0, 23, 836, 0, 44] addi 5 8 5 [1, 0, 23, 836, 0, 52]
ip=24 [1, 0, 24, 836, 0, 52] addr 3 5 3 [1, 0, 24, 888, 0, 52]
ip=25 [1, 0, 25, 888, 0, 52] addr 2 0 2 [1, 0, 26, 888, 0, 52]
====> skips 26, so continues to build up numbers
ip=27 [1, 0, 27, 888, 0, 52] setr 2 5 5 [1, 0, 27, 888, 0, 27]
ip=28 [1, 0, 28, 888, 0, 27] mulr 5 2 5 [1, 0, 28, 888, 0, 756]
ip=29 [1, 0, 29, 888, 0, 756] addr 2 5 5 [1, 0, 29, 888, 0, 785]
ip=30 [1, 0, 30, 888, 0, 785] mulr 2 5 5 [1, 0, 30, 888, 0, 23550]
ip=31 [1, 0, 31, 888, 0, 23550] muli 5 14 5 [1, 0, 31, 888, 0, 329700]
ip=32 [1, 0, 32, 888, 0, 329700] mulr 5 2 5 [1, 0, 32, 888, 0, 10550400]
ip=33 [1, 0, 33, 888, 0, 10550400] addr 3 5 3 [1, 0, 33, 10551288, 0, 10550400]
ip=34 [1, 0, 34, 10551288, 0, 10550400] seti 0 8 0 [0, 0, 34, 10551288, 0, 10550400]
ip=35 [0, 0, 35, 10551288, 0, 10550400] seti 0 5 2 [0, 0, 0, 10551288, 0, 10550400]
===>  Now jumpts to one , and the counter is at
      10551288, so this will look 10_551_288
ip=1 [0, 0, 1, 10551288, 0, 10550400] seti 1 2 4 [0, 0, 1, 10551288, 1, 10550400]
ip=2 [0, 0, 2, 10551288, 1, 10550400] seti 1 8 1 [0, 1, 2, 10551288, 1, 10550400]


ip=3 [0, 1, 3, 10551288, 1, 10550400] mulr 4 1 5 [0, 1, 3, 10551288, 1, 1]

